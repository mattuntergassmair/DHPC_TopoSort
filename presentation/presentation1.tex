\input{./beamerheader.sty}

\author[]{Kevin Wallimann \quad Johannes Baum \quad Matthias Untergassmair}

%----------------------------------------------------------------------------------------
%	TITLE PAGE
%----------------------------------------------------------------------------------------

\title[Topological Sorting]{Parallel Topological Sorting} % The short title appears at the bottom of every slide, the full title is only on the title page
\subtitle{Design of High Performance Computing, Fall 2015}

\institute[ETHZ]{ ETH ZÃ¼rich }
%\date{\today} % Date, can be changed to a custom date
\date{November 2, 2015}
\begin{document}

\begin{frame}
\titlepage % Print the title page as the first slide
\end{frame}

%----------------------------------------------------------------------------------------
%	PRESENTATION SLIDES
%----------------------------------------------------------------------------------------

%------------------------------------------------
\section{Topic}
%------------------------------------------------

\subsection{Problem Description}
% TODO: Johannes

\begin{frame}
\frametitle{Problem Description}

\begin{description}
	\item[Input] Directed acyclic graph (DAG) with $N$ nodes
	\item[Output] Topological Sortings of DAG
\end{description}

\end{frame}




%------------------------------------------------
\subsection{Related Work}
%------------------------------------------------

% TODO: Johannes
\begin{frame}
\frametitle{"Efficient" Parallel and Distributed Topological Sort Algorithms}

\begin{itemize}
	\item Runtime: $\mathcal{O} (\log^2 N)$
	\item Reduces to matrix-matrix multiplication problem
\end{itemize}

\begin{block}{Problem:}
	$\mathcal{O} (N^3)$ execution units required
\end{block}


\end{frame}




%------------------------------------------------
\section{Serial Implementation}
%------------------------------------------------
% TODO: matthias (2min)
% linked list of nodes

\subsection{UML}
\begin{frame}
	\frametitle{UML Diagram}
	\begin{center}
		\includegraphics[width=.8\textwidth]{img/toposortUML}
	\end{center}
\end{frame}

\subsection{Code}
\begin{frame}
	\frametitle{Serial Code}
	\begin{center}
		\includegraphics[width=\textwidth]{img/code1} \\
		\includegraphics[width=\textwidth]{img/code2} \\
		\pause
		\includegraphics[width=\textwidth]{img/code3}
	\end{center}
\end{frame}
% \begin{frame}[fragile]
% 	\frametitle{Serial Code}
% 	\begin{lstlisting}[style=cpp]
% std::list<Node*> currentnodes;
% . . .
% Node* parent, child;
% unsigned childcount = currentvalue = 0;
% . . .
% while(!currentnodes.empty()) {
%   parent = currentnodes.front();
%   currentnodes.pop_front();
%   currentvalue = parent->getValue();
%   ++currentvalue;
%   childcount = parent->getChildCount();
%   for(unsigned i=0; i<childcount; ++i) {
%     child = parent->getChild(i);
%     currentnodes.push_back(child);
%     child->setValue(currentvalue);
%   }
% }
% \end{lstlisting}
% \end{frame}


%------------------------------------------------
\section{Parallelization}
%------------------------------------------------
% TODO: Kevin (3min)
\begin{frame}

\frametitle{Parallelization Ideas}
\begin{columns}
  \begin{column}{0.5\textwidth}
    \begin{itemize}
        \item Start in parallel at source nodes
        \item Spawn a new thread for every child node
        \item Synchronization needed when a node has multiple parents
        \item Performance dependent on topology of graph. Worst case $\mathcal{O}(n)$
    \end{itemize}
  \end{column}
  
  \begin{column}{0.5\textwidth}
    \begin{figure}[ht]
    %%TODO: Replace with more beautiful graph
    \includegraphics[width=0.4\textwidth]{img/paper}
    \end{figure}
  \end{column}
\end{columns}

\end{frame}

\begin{frame}
\frametitle{Synchronization ideas}
\begin{columns}
  \begin{column}{0.5\textwidth}
    \begin{itemize}
            \item Each thread enumerates the nodes it visits.
            \item If a node already has a number, take the higher number
    \end{itemize}
    \vspace{0.3cm}
    \begin{itemize}
            \item Problem: Multiple threads might ``follow'' each other.
            \item Idea: Only last thread arriving at a node may continue.
    \end{itemize}
  \end{column}
%   
  \begin{column}{0.5\textwidth}
    \begin{figure}[ht]
    %%TODO: Replace with more beautiful graph
    \includegraphics[width=0.4\textwidth]{img/paper}
    \end{figure}
  \end{column}
\end{columns}
\end{frame}

\begin{frame}
\frametitle{Hardware / Tools}
%TODO: Do we want to try MPI? Only makes things worse. We have no good way of fine-grained / coarse-grained parallelism
\begin{itemize}
        \item Shared memory parallelization
        \item OpenMP or C\texttt{++}11 threads.
        \item On Euler: 12-core Intel Xeon E5
        \item Intel Xeon Phi
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Challenges}
\begin{itemize}
	\item Task queue
	\item Find a way to cope with chain-like graphs.
	\item Optional goal: Find all possible topological sortings.
\end{itemize}
\end{frame}


\begin{frame}
\frametitle{Questions}
\begin{itemize}
	\item Up to how many execution units should we parallelize at least?
	\item From your experience, what are the main time-consuming, maybe unexpected obstacles when running on Intel Xeon Phi?
\end{itemize}
\end{frame}


\end{document} 
