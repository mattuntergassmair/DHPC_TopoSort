\section{Introduction}\label{sec:intro}

\mypar{Motivation}
Topological sorting is used to yield a total order from a partial order. For example this is needed when serializing a set of tasks or jobs which depend on each other. Besides task-scheduling it can also be used by a linker to resolve software dependencies. During static code analysis the compiler can use topological sorting to rearrange different code slices. Another example is proving a parallel program sequentially consistent. A parallel implementation of a topological sorting algorithm is challenging, because of the high memory consumption of the algorithms. Since future applications of high performance computing shift towards memory bound problems, the need for a parallel topological algorithm dealing with memory limitation could become more important in the future.

\mypar{Related work} 
M.C. Er \cite{er1983parallel} proposed a parallel algorithm for topological sorting in 1983. This graph algorithm assigns every node a value in parallel. To ensure correctness a barrier is necessary after each node processed. The asymptotic runtime of this algorithm is limited by the longest distance between a source and a sink node. Unfortunately it is left unclear how to retrieve a topological sorting from the node values without sorting them. Furthermore it is not considered that nodes can be processed by several processes, which does not break correctness but decreases the performance. Also, there is no information about work balancing, such that the algorithm is not practicable in the proposed shape.

Ma \cite{ma1997efficient} proposed an algorithm solving the problem using an adjacency matrix of the graph and calculating the transitive closure of that matrix. This results in an asymptotic runtime  of $\mathcal{O}(log^2 |V|)$ on $\mathcal{O}(|V|^3)$ processors, where $V$ is the set of vertices of the graph. This analysis uses the Parallel Random Access Machine (PRAM) model and because of the exponential growth of needed processors the algorithm is not useful in practise.

Both algorithms are proposed without code and have not been implemented by their authors.

In this report a parallel algorithm based on the one by M.C. Er is proposed. It addresses the described issues preventing it from being of use in practice and has been implemented and evaluated.


\begin{invisible}
  \begin{itemize}
  \item Software Dependencies
  \item Maybe, to flesh out: Admittedly a bit academic, but interesting problem nevertheless, because memory bound => This is the future of HPC
  \end{itemize}
\end{invisible}


\begin{invisible}
  \begin{itemize}
  \item MC Er Paper \cite{er1983parallel}: Unclear how to retrieve a sorted list from values without sorting and threads might chase other threads. No words about load balancing => Not practicable
  \item Ma Paper \cite{ma1997efficient}: Theoretical analysis in PRAM model, not practicable.
  \item Both cases: No code
  \item Our contribution: (1) Modified algorithm based on MC Er. 1. Sorted list is directly extracted. 2. only one thread continues when multiple threads meet. 3. Ensure load balancing
                          (2) Actual implementation for shared memory architecture
  \end{itemize}
\end{invisible}

